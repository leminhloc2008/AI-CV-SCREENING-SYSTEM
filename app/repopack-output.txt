================================================================
Repopack Output File
================================================================

This file was generated by Repopack on: 2025-01-23T06:07:05.427Z

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This header section
2. Repository structure
3. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
1. This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
2. When processing this file, use the separators and "File:" markers to
  distinguish between different files in the repository.
3. Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repopack's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.



For more information about Repopack, visit: https://github.com/yamadashy/repopack

================================================================
Repository Structure
================================================================
data/companies.json
data/technical_terms.json
data/universities.json
models/resume.py
models/scoring_rules.py
modules/document_extraction/extractor.py
modules/document_extraction/ocr.py
modules/embedding/embedder.py
modules/embedding/similarity.py
modules/scoring/awards.py
modules/scoring/certifications.py
modules/scoring/education.py
modules/scoring/experience.py
modules/scoring/projects.py
modules/scoring/scorer.py
modules/summarization/evaluator.py
modules/summarization/summarizer.py
tests/tempCodeRunnerFile.py
tests/test_awards.py
tests/test_certification.py
tests/test_cv_evaluation.py
tests/test_cv_summarization.py
tests/test_document_extraction.py
tests/test_education.py
tests/test_embedding.py
tests/test_experience.py
tests/test_scoring.py
utils/bias_check.py
utils/json_lookup.py
utils/normalization.py

================================================================
Repository Files
================================================================

================
File: data/companies.json
================
{
    "FPT Software": 20,
    "VinGroup": 15,
    "Viettel": 20,
    "VNG Corporation": 15,
    "Momo": 15,
    "Shopee": 20,
    "Lazada": 20,
    "Grab": 20,
    "Google": 25,
    "Microsoft": 25,
    "Amazon": 25,
    "Startups (1-10 employees)": 5,
    "Startups (11-50 employees)": 10,
    "Startups (51-100 employees)": 15,
    "Scale-ups (101-500 employees)": 20,
    "Established Companies (501-1000 employees)": 25,
    "MNCs (1000+ employees)": 25,
    "Others": 10
  }

================
File: data/technical_terms.json
================
{
    "technical_majors": [
      "computer",
      "software",
      "data",
      "information",
      "cyber",
      "cloud",
      "web",
      "ai",
      "machine learning",
      "analytics",
      "engineering",
      "robotics",
      "mechatronics",
      "automation",
      "industrial",
      "mathematics",
      "statistics",
      "physics",
      "chemistry",
      "biology",
      "computational",
      "applied",
      "electrical",
      "electronics",
      "telecommunications",
      "mechanical",
      "manufacturing",
      "interaction design",
      "user experience",
      "ux",
      "civil"
    ],
    "technical_positions": [
      "software",
      "frontend",
      "backend",
      "web",
      "mobile",
      "full stack",
      "data",
      "machine learning",
      "ai",
      "devops",
      "it",
      "network",
      "cybersecurity",
      "penetration",
      "security",
      "system",
      "cloud",
      "site reliability",
      "infrastructure",
      "ci/cd",
      "hardware",
      "embedded system",
      "firmware",
      "robotics",
      "mechanical",
      "electrical",
      "automation",
      "sensor",
      "circuit",
      "product",
      "ui/ux",
      "product management",
      "design",
      "interaction",
      "experience",
      "analyst",
      "scientist",
      "engineer",
      "developer",
      "programmer",
      "specialist",
      "consultant",
      "administrator",
      "architect"
    ],
    "technical_skills": [
      "python",
      "java",
      "c++",
      "javascript",
      "react",
      "angular",
      "vue",
      "node.js",
      "sql",
      "mongodb",
      "tensorflow",
      "pytorch",
      "keras",
      "scikit-learn",
      "docker",
      "kubernetes",
      "aws",
      "azure",
      "google cloud",
      "git",
      "jenkins",
      "ansible",
      "terraform",
      "linux",
      "bash",
      "networking",
      "cybersecurity",
      "machine learning",
      "data analysis",
      "big data",
      "artificial intelligence",
      "cloud computing",
      "devops",
      "agile",
      "scrum"
    ]
  }

================
File: data/universities.json
================
{
    "HUST": 20,
    "RMIT University Vietnam": 20,
    "VinUniversity": 15,
    "FPT University": 15,
    "British University Vietnam (BUV)": 15,
    "University of Greenwich Vietnam": 15,
    "University of Science and Technology of Hanoi (USTH)": 15,
    "Swinburne University of Technology (Vietnam)": 15,
    "Western Sydney University Vietnam": 15,
    "Hanoi University of Science and Technology (HUST)": 20,
    "VNU University of Engineering and Technology (VNU-UET)": 20,
    "Posts and Telecommunications Institute of Technology (PTIT)": 20,
    "Ho Chi Minh City University of Technology (HCMUT)": 20,
    "Vietnam National University, Ho Chi Minh City (VNU-HCM)": 20,
    "University of Economics and Law (UEL) - VNU-HCM": 20,
    "University of Danang - University of Science and Technology": 15,
    "University of Danang - University of Science and Technology (DUT)": 15,
    "Others": 10
  }

================
File: models/resume.py
================
from pydantic import BaseModel, Field
from typing import List, Optional

class EducationItem(BaseModel):
    school: str
    class_year: str
    major: str
    minor: Optional[str] = None
    gpa: Optional[float] = None

class ProfessionalExperienceItem(BaseModel):
    company: str
    location: str
    position: str
    seniority: str
    duration: str
    description: str

class ProjectItem(BaseModel):
    name: str
    link: Optional[str] = None
    tech: Optional[str] = None
    duration: Optional[str] = None
    description: str

class AwardItem(BaseModel):
    contest: str
    prize: str
    description: str
    role: Optional[str] = None
    link: Optional[str] = None
    time: str

class CertificationItem(BaseModel):
    name: str
    link: Optional[str] = None
    org: Optional[str] = None

class SkillItem(BaseModel):
    name: str
    list: List[str]

class Resume(BaseModel):
    name: str
    location: str
    social: List[str]
    email: str
    linkedin: Optional[str] = None
    phone: str
    intro: str
    education: List[EducationItem]
    professional_experience: List[ProfessionalExperienceItem]
    projects: List[ProjectItem]
    awards: List[AwardItem]
    certifications: List[CertificationItem]
    skills: List[SkillItem]

================
File: models/scoring_rules.py
================
SCORING_RULES = {
    "education": {
        "weight": 15,  # 15% of the total score
        "school": 30,
        "class_year": 30,
        "major": 30,
        "minor": 0,
        "gpa": 10
    },
    "professional_experience": {
        "weight": 25,  # 25% of the total score
        "company": 25,
        "location": 5,
        "position": 25,
        "seniority": 5,
        "duration": 5,
        "description": 25
    },
    "projects": {
        "weight": 20,  # 20% of the total score
        "name": 10,
        "link": 20,
        "tech": 25,
        "duration": 5,
        "description": 40
    },
    "awards": {
        "weight": 15,  # 15% of the total score
        "contest": 30,
        "prize": 25,
        "description": 25,
        "role": 10,
        "link": 5,
        "time": 5
    },
    "certifications": {
        "weight": 5,  # 5% of the total score
        "name": 50,
        "link": 10,
        "org": 40
    },
    "skills": {
        "weight": 5,  # 5% of the total score
        "name": 50,
        "list": 50
    }
}

================
File: modules/document_extraction/extractor.py
================
from app.models.resume import Resume, EducationItem, ProfessionalExperienceItem, ProjectItem, AwardItem, CertificationItem, SkillItem
from .ocr import extract_structured_data_from_cv
import re
from typing import List, Optional

def extract_resume(file_path: str) -> Resume:
    """
    Extract structured data from a CV (PDF or DOCX) using LLM and return a Resume object.
    """
    # Step 1: Extract raw text from the CV
    cv_text = extract_text_from_cv(file_path)

    # Step 2: Use LLM to extract structured data
    structured_data = extract_structured_data_from_cv(cv_text)

    print(structured_data)
    
    # Step 3: Convert the structured data into a Resume object
    return Resume(
        name=structured_data.get("name", "Unknown"),
        location=structured_data.get("location", "Unknown"),
        social=structured_data.get("social", []),
        email=structured_data.get("email", "Unknown"),
        linkedin=structured_data.get("linkedin", None),
        phone=structured_data.get("phone", "Unknown"),
        intro=structured_data.get("intro", "No introduction provided."),
        education=[EducationItem(**edu) for edu in structured_data.get("education", [])],
        professional_experience=[ProfessionalExperienceItem(**exp) for exp in structured_data.get("professional_experience", [])],
        projects=[ProjectItem(**proj) for proj in structured_data.get("projects", [])],
        awards=[AwardItem(**award) for award in structured_data.get("awards", [])],
        certifications=[CertificationItem(**cert) for cert in structured_data.get("certifications", [])],
        skills=[SkillItem(**skill) for skill in structured_data.get("skills", [])]
    )

def extract_text_from_cv(file_path: str) -> str:
    """
    Extract raw text from a CV file (PDF or DOCX).
    """
    if file_path.endswith(".pdf"):
        return extract_text_from_pdf(file_path)
    elif file_path.endswith(".docx"):
        return extract_text_from_docx(file_path)
    else:
        # Assume it's a plain text file
        with open(file_path, "r") as file:
            return file.read()

def extract_text_from_pdf(file_path: str) -> str:
    """
    Extract text from a PDF file.
    """
    import PyPDF2
    with open(file_path, "rb") as file:
        reader = PyPDF2.PdfReader(file)
        text = ""
        for page in reader.pages:
            text += page.extract_text()
        return text

def extract_text_from_docx(file_path: str) -> str:
    """
    Extract text from a DOCX file.
    """
    from docx import Document
    doc = Document(file_path)
    text = ""
    for paragraph in doc.paragraphs:
        text += paragraph.text + "\n"
    return text

================
File: modules/document_extraction/ocr.py
================
from openai import OpenAI
from dotenv import load_dotenv
import os, json, openai, re

# Load environment variables
load_dotenv()
openai.api_key = os.getenv("OPENAI_API_KEY")

def extract_structured_data_from_cv(cv_text: str) -> dict:
    """
    Extract structured data from CV text using OpenAI's API.
    Returns a dictionary containing structured resume data.
    """
    # Initialize the OpenAI client
    client = OpenAI()
    
    # Create the prompt from the CV text
    prompt = f"""
    Extract the following fields from the CV below and return the result as a valid JSON object. Do not include any additional text or explanations. Only return the JSON object.

    Required JSON structure:
    {{
        "name": "string",
        "location": "string",
        "social": ["string"],
        "email": "string",
        "linkedin": "string or null",
        "phone": "string",
        "intro": "string",
        "education": [{{
            "school": "string",
            "class_year": "string",
            "major": "string",
            "gpa": "string"
        }}],
        "professional_experience": [{{
            "company": "string",
            "location": "string",
            "position": "string",
            "seniority": "string",
            "duration": "string",
            "description": "string"
        }}],
        "projects": [{{
            "name": "string",
            "tech": "string",
            "duration": "string",
            "description": "string"
        }}],
        "awards": [{{
            "contest": "string",
            "prize": "string",
            "description": "string",
            "time": "string"
        }}],
        "certifications": [{{
            "name": "string",
            "org": "string",
            "link": "string"
        }}],
        "skills": [{{
            "name": "string",
            "list": ["string"]
        }}]
    }}

    CV Text:
    {cv_text}"""
    
    try:
        response = client.chat.completions.create(
            model="gpt-3.5-turbo",
            messages=[
                {
                    "role": "system", 
                    "content": "You are a professional CV parser. Return only valid JSON that matches the required structure exactly."
                },
                {"role": "user", "content": prompt}
            ],
            max_tokens=2000,
            temperature=0.3
        )
        
        response_content = response.choices[0].message.content.strip()
        if not response_content:
            print("Empty response from API")
            return create_default_structure()
            
        try:
            structured_data = json.loads(response_content)
            if not isinstance(structured_data, dict):
                print("Response is not a dictionary")
                return create_default_structure()
                
            # Fix skills structure if needed
            if "skills" in structured_data:
                for skill in structured_data["skills"]:
                    if "skills" in skill and "list" not in skill:
                        skill["list"] = skill.pop("skills")
                    elif "list" not in skill:
                        skill["list"] = []
                        
        except json.JSONDecodeError as e:
            print(f"Failed to parse JSON response: {e}")
            print(f"Raw response: {response_content}")
            return create_default_structure()
            
    except Exception as e:
        print(f"Error during API call: {e}")
        return create_default_structure()
    
    # Ensure all required fields exist
    default_structure = create_default_structure()
    for key in default_structure:
        if key not in structured_data:
            structured_data[key] = default_structure[key]
    
    return structured_data

def create_default_structure() -> dict:
    """
    Creates a default structure for the resume data.
    """
    return {
        "name": "Unknown",
        "location": "Unknown",
        "social": [],
        "email": "Unknown",
        "linkedin": None,
        "phone": "Unknown",
        "intro": "No introduction provided.",
        "education": [],
        "professional_experience": [],
        "projects": [],
        "awards": [],
        "certifications": [],
        "skills": [{"name": "Unknown", "list": []}]
    }

================
File: modules/embedding/embedder.py
================
from transformers import AutoTokenizer, AutoModel
import torch
from typing import List


def get_embeddings(texts: List[str]) -> List[List[float]]:
    """
    Generate embeddings for a list of texts using PhoBERT.
    """
    tokenizer = AutoTokenizer.from_pretrained("vinai/phobert-base")
    model = AutoModel.from_pretrained("vinai/phobert-base")

    inputs = tokenizer(texts, return_tensors="pt", padding=True, truncation=True)
    with torch.no_grad():
        outputs = model(**inputs)
    embeddings = outputs.last_hidden_state.mean(dim=1).tolist()
    return embeddings

================
File: modules/embedding/similarity.py
================
from typing import List
from sklearn.metrics.pairwise import cosine_similarity

def calculate_similarity(embedding1: List[float], embedding2: List[float]) -> float:
    """
    Calculate cosine similarity between two embeddings.
    """
    return cosine_similarity([embedding1], [embedding2])[0][0]

================
File: modules/scoring/awards.py
================
from app.models.resume import AwardItem
from app.models.scoring_rules import SCORING_RULES
from typing import List, Optional

def calculate_awards_score(awards: List[AwardItem]) -> float:
    """
    Calculate the awards score based on contest prestige, prize, and description.
    """
    total_score = 0.0

    for award in awards:
        # Contest Prestige (30%)
        contest_score = calculate_contest_score(award.contest) * SCORING_RULES["awards"]["contest"]

        # Prize (25%)
        prize_score = calculate_prize_score(award.prize) * SCORING_RULES["awards"]["prize"]

        # Description (25%)
        description_score = calculate_description_score(award.description) * SCORING_RULES["awards"]["description"]

        # Role (10%)
        role_score = 10 if is_technical_role(award.role) else 0

        # Link (5%)
        link_score = 5 if award.link else 0

        # Time (5%)
        time_score = 5 if award.time else 0

        # Total Award Score
        total_score += contest_score + prize_score + description_score + role_score + link_score + time_score

    return total_score

def calculate_contest_score(contest: str) -> int:
    """
    Calculate the score based on the contest's prestige.
    """
    if "international" in contest.lower():
        return 10
    elif "national" in contest.lower():
        return 8
    elif "local" in contest.lower():
        return 5
    else:
        return 2

def calculate_prize_score(prize: str) -> int:
    """
    Calculate the score based on the prize level.
    """
    if "1st" in prize.lower() or "gold" in prize.lower():
        return 25
    elif "2nd" in prize.lower() or "silver" in prize.lower():
        return 20
    elif "3rd" in prize.lower() or "bronze" in prize.lower():
        return 15
    else:
        return 10

def calculate_description_score(description: str) -> int:
    """
    Calculate the score based on the description's clarity and impact.
    """
    score = 0

    # Clarity and Focus (30%)
    if "developed" in description.lower() or "designed" in description.lower():
        score += 10

    # Achievements/Impact (30%)
    if "reduced" in description.lower() or "improved" in description.lower():
        score += 10

    # Use of Tools/Technologies (20%)
    if "python" in description.lower() or "sql" in description.lower():
        score += 10

    return score

def is_technical_role(role: Optional[str]) -> bool:
    """
    Check if the role is relevant to technical fields.
    """
    if not role:
        return False
    technical_keywords = ["developer", "engineer", "data scientist", "analyst"]
    return any(keyword in role.lower() for keyword in technical_keywords)

================
File: modules/scoring/certifications.py
================
from app.models.resume import CertificationItem
from app.models.scoring_rules import SCORING_RULES
from typing import List, Optional

def calculate_certifications_score(certifications: List[CertificationItem]) -> float:
    """
    Calculate the certifications score based on name, organization, and link.
    """
    total_score = 0.0

    for cert in certifications:
        # Name (50%)
        name_score = calculate_name_score(cert.name) * SCORING_RULES["certifications"]["name"]

        # Organization (40%)
        org_score = calculate_org_score(cert.org) * SCORING_RULES["certifications"]["org"]

        # Link (10%)
        link_score = 10 if cert.link else 0

        # Total Certification Score
        total_score += name_score + org_score + link_score

    return total_score

def calculate_name_score(name: str) -> int:
    """
    Calculate the score based on the certification name's relevance.
    """
    if "aws" in name.lower() or "google" in name.lower() or "microsoft" in name.lower():
        return 50
    elif "data" in name.lower() or "cloud" in name.lower() or "ai" in name.lower():
        return 30
    else:
        return 10

def calculate_org_score(org: Optional[str]) -> int:
    """
    Calculate the score based on the organization's reputation.
    """
    if not org:
        return 0
    if "aws" in org.lower() or "google" in org.lower() or "microsoft" in org.lower():
        return 40
    elif "udemy" in org.lower() or "coursera" in org.lower():
        return 25
    else:
        return 10

================
File: modules/scoring/education.py
================
from app.models.resume import EducationItem
from app.models.scoring_rules import SCORING_RULES
from app.utils.json_lookup import get_university_score
from typing import List

def calculate_education_score(education: List[EducationItem]) -> float:
    """
    Calculate the education score based on school reputation, major relevance, and GPA.
    """
    total_score = 0.0

    for edu in education:
        # School Reputation (30%)
        school_score = get_university_score(edu.school) * SCORING_RULES["education"]["school"]

        # Major Relevance (30%)
        major_score = 30 if is_technical_major(edu.major) else 0

        # GPA (10%)
        gpa_score = 0
        if edu.gpa:
            if edu.gpa >= 3.2:
                gpa_score = 10
            elif 2.8 <= edu.gpa < 3.2:
                gpa_score = 5

        # Class Year (30%)
        class_score = calculate_class_score(edu.class_year)

        # Total Education Score
        total_score += school_score + major_score + gpa_score + class_score

    return total_score

def is_technical_major(major: str) -> bool:
    """
    Check if the major is relevant to technical fields.
    """
    technical_keywords = ["computer", "software", "data", "information", "cyber", "cloud", "web", "ai", "machine learning", "analytics"]
    return any(keyword in major.lower() for keyword in technical_keywords)

def calculate_class_score(class_year: str) -> int:
    """
    Calculate the score based on the class year.
    """
    if class_year.lower() == "senior":
        return 30
    elif class_year.lower() == "junior":
        return 20
    elif class_year.lower() == "sophomore":
        return 10
    else:
        return 10

================
File: modules/scoring/experience.py
================
from app.models.resume import ProfessionalExperienceItem
from app.models.scoring_rules import SCORING_RULES
from app.utils.json_lookup import get_company_score
from typing import List

def calculate_experience_score(experience: List[ProfessionalExperienceItem]) -> float:
    """
    Calculate the professional experience score based on company size, position relevance, and description.
    """
    total_score = 0.0

    for exp in experience:
        # Company Size (25%)
        company_score = get_company_score(exp.company) * (SCORING_RULES["professional_experience"]["company"] / 100)

        # Position Relevance (25%)
        position_score = 25 if is_technical_position(exp.position) else 0

        # Description (25%)
        description_score = calculate_description_score(exp.description) * (SCORING_RULES["professional_experience"]["description"] / 100)

        # Seniority (5%)
        seniority_score = 5 if exp.seniority.lower() in ["senior", "lead", "manager"] else 0

        # Duration (5%)
        duration_score = 5 if calculate_duration(exp.duration) >= 6 else 0

        # Total Experience Score
        total_score += company_score + position_score + description_score + seniority_score + duration_score

    return total_score

def is_technical_position(position: str) -> bool:
    """
    Check if the position is relevant to technical roles.
    """
    technical_keywords = ["software", "frontend", "backend", "web", "mobile", "full stack", "data", "machine learning", "ai", "devops"]
    return any(keyword in position.lower() for keyword in technical_keywords)

def calculate_description_score(description: str) -> int:
    """
    Calculate the score based on the description's clarity, impact, and use of tools.
    """
    score = 0

    # Clarity and Focus (30%)
    if "developed" in description.lower() or "designed" in description.lower():
        score += 10

    # Achievements/Impact (30%)
    if "reduced" in description.lower() or "improved" in description.lower():
        score += 10

    # Use of Tools/Technologies (20%)
    if "python" in description.lower() or "sql" in description.lower():
        score += 10

    return score

def calculate_duration(duration: str) -> int:
    """
    Calculate the duration in months.
    """
    try:
        # Handle different duration formats (e.g., "Jan 2020 - Dec 2021" or "2 years")
        if " - " in duration:
            # Format: "Jan 2020 - Dec 2021"
            start, end = duration.split(" - ")
            start_year = int(start.split()[-1])
            end_year = int(end.split()[-1])
            return (end_year - start_year) * 12
        elif "year" in duration:
            # Format: "2 years"
            years = int(duration.split()[0])
            return years * 12
        elif "month" in duration:
            # Format: "6 months"
            months = int(duration.split()[0])
            return months
        else:
            # Default to 0 if the format is unrecognized
            return 0
    except:
        # If parsing fails, return 0
        return 0

================
File: modules/scoring/projects.py
================
from typing import List, Optional
from app.models.resume import ProjectItem
from app.models.scoring_rules import SCORING_RULES

def calculate_projects_score(projects: List[ProjectItem]) -> float:
    """
    Calculate the projects score based on tech stack, GitHub link, and description.
    """
    total_score = 0.0

    for project in projects:
        # Tech Stack (25%)
        tech_score = 25 if is_technical_project(project.tech) else 0

        # GitHub Link (20%)
        link_score = 20 if project.link else 0

        # Description (40%)
        description_score = calculate_description_score(project.description)

        # Total Project Score
        total_score += tech_score + link_score + description_score

    return total_score

def is_technical_project(tech: Optional[str]) -> bool:
    """
    Check if the project uses relevant technologies.
    """
    if not tech:
        return False
    technical_keywords = ["python", "java", "sql", "tensorflow", "react", "docker"]
    return any(keyword in tech.lower() for keyword in technical_keywords)

def calculate_description_score(description: str) -> int:
    """
    Calculate the score based on the description's clarity, impact, and use of tools.
    """
    score = 0

    # Clarity and Focus (30%)
    if "developed" in description.lower() or "designed" in description.lower():
        score += 10

    # Achievements/Impact (30%)
    if "reduced" in description.lower() or "improved" in description.lower():
        score += 10

    # Use of Tools/Technologies (20%)
    if "python" in description.lower() or "sql" in description.lower():
        score += 10

    return score

================
File: modules/scoring/scorer.py
================
from app.models.resume import Resume
from app.models.scoring_rules import SCORING_RULES
from .education import calculate_education_score
from .experience import calculate_experience_score
from .projects import calculate_projects_score
from .awards import calculate_awards_score
from .certifications import calculate_certifications_score

def calculate_total_score(resume: Resume) -> float:
    """
    Calculate the total score for a resume by aggregating scores from all fields.
    """
    total_score = 0.0

    # Education Score
    education_score = calculate_education_score(resume.education)
    total_score += education_score * (SCORING_RULES["education"]["weight"] / 100)

    # Professional Experience Score
    experience_score = calculate_experience_score(resume.professional_experience)
    total_score += experience_score * (SCORING_RULES["professional_experience"]["weight"] / 100)

    # Projects Score
    projects_score = calculate_projects_score(resume.projects)
    total_score += projects_score * (SCORING_RULES["projects"]["weight"] / 100)

    # Awards Score
    awards_score = calculate_awards_score(resume.awards)
    total_score += awards_score * (SCORING_RULES["awards"]["weight"] / 100)

    # Certifications Score
    certifications_score = calculate_certifications_score(resume.certifications)
    total_score += certifications_score * (SCORING_RULES["certifications"]["weight"] / 100)

    return total_score

================
File: modules/summarization/evaluator.py
================
from openai import OpenAI
from dotenv import load_dotenv
import os
from app.models.resume import Resume

load_dotenv()

def evaluate_resume(resume: Resume) -> str:
    """
    Evaluate a resume using OpenAI's API.
    """
    # Initialize the OpenAI client
    client = OpenAI(api_key=os.getenv("OPENAI_API_KEY"))
    
    # Create the prompt from the resume data
    prompt = f"Please evaluate the following resume:\n{resume}"
    
    # Use the new chat completion endpoint
    response = client.chat.completions.create(
        model="gpt-4o",  
        messages=[
            {"role": "system", "content": "You are a professional resume evaluator. Provide a detailed evaluation of the resume."},
            {"role": "user", "content": prompt}
        ],
        max_tokens=1000,
        temperature=0.7
    )
    
    # Extract the evaluation from the response
    evaluation = response.choices[0].message.content
    
    return evaluation

def format_resume_for_evaluation(resume: Resume) -> str:
    """
    Format the resume into a text string for evaluation.
    """
    evaluation = f"Name: {resume.name}\n"
    evaluation += f"Location: {resume.location}\n"
    evaluation += f"Email: {resume.email}\n"
    evaluation += f"LinkedIn: {resume.linkedin}\n"
    evaluation += f"Phone: {resume.phone}\n"
    evaluation += f"Intro: {resume.intro}\n"

    evaluation += "\nEducation:\n"
    for edu in resume.education:
        evaluation += f"- {edu.school}, {edu.major}, {edu.class_year}, GPA: {edu.gpa}\n"

    evaluation += "\nProfessional Experience:\n"
    for exp in resume.professional_experience:
        evaluation += f"- {exp.company}, {exp.position}, {exp.duration}\n"
        evaluation += f"  {exp.description}\n"

    evaluation += "\nProjects:\n"
    for project in resume.projects:
        evaluation += f"- {project.name}, {project.tech}, {project.duration}\n"
        evaluation += f"  {project.description}\n"

    evaluation += "\nAwards:\n"
    for award in resume.awards:
        evaluation += f"- {award.contest}, {award.prize}, {award.time}\n"
        evaluation += f"  {award.description}\n"

    evaluation += "\nCertifications:\n"
    for cert in resume.certifications:
        evaluation += f"- {cert.name}, {cert.org}\n"

    evaluation += "\nSkills:\n"
    for skill in resume.skills:
        evaluation += f"- {skill.name}: {', '.join(skill.list)}\n"

    return evaluation

================
File: modules/summarization/summarizer.py
================
from openai import OpenAI
from dotenv import load_dotenv
import os
from app.models.resume import Resume

load_dotenv()

def summarize_resume(resume: Resume) -> str:
    """
    Summarize a resume using OpenAI's API.
    """
    # Initialize the OpenAI client
    client = OpenAI(api_key=os.getenv("OPENAI_API_KEY"))
    
    prompt = f"Please summarize the following resume:\n{resume}"
    
    response = client.chat.completions.create(
        model="gpt-4o",  
        messages=[
            {"role": "system", "content": "You are a professional resume reviewer. Summarize the key points of the resume concisely."},
            {"role": "user", "content": prompt}
        ],
        max_tokens=500,
        temperature=0.7
    )
    
    # Extract the summary from the response
    summary = response.choices[0].message.content
    
    return summary

def format_resume_for_summary(resume: Resume) -> str:
    """
    Format the resume into a text string for summarization.
    """
    summary = f"Name: {resume.name}\n"
    summary += f"Location: {resume.location}\n"
    summary += f"Email: {resume.email}\n"
    summary += f"LinkedIn: {resume.linkedin}\n"
    summary += f"Phone: {resume.phone}\n"
    summary += f"Intro: {resume.intro}\n"

    summary += "\nEducation:\n"
    for edu in resume.education:
        summary += f"- {edu.school}, {edu.major}, {edu.class_year}, GPA: {edu.gpa}\n"

    summary += "\nProfessional Experience:\n"
    for exp in resume.professional_experience:
        summary += f"- {exp.company}, {exp.position}, {exp.duration}\n"
        summary += f"  {exp.description}\n"

    summary += "\nProjects:\n"
    for project in resume.projects:
        summary += f"- {project.name}, {project.tech}, {project.duration}\n"
        summary += f"  {project.description}\n"

    summary += "\nAwards:\n"
    for award in resume.awards:
        summary += f"- {award.contest}, {award.prize}, {award.time}\n"
        summary += f"  {award.description}\n"

    summary += "\nCertifications:\n"
    for cert in resume.certifications:
        summary += f"- {cert.name}, {cert.org}\n"

    summary += "\nSkills:\n"
    for skill in resume.skills:
        summary += f"- {skill.name}: {', '.join(skill.list)}\n"

    return summary

================
File: tests/tempCodeRunnerFile.py
================
import pytest
from app.models.resume import ProfessionalExperienceItem
from app.modules.scoring.experience import calculate_experience_score

def test_calculate_experience_score():
    experience = [
        ProfessionalExperienceItem(company="FPT Software", location="Hanoi", position="Software Engineer", seniority="Junior", duration="2 years", description="Developed web applications using Python and Django.")
    ]
    score = calculate_experience_score(experience)
    assert score == 65  # FPT Software (20) + Software Engineer (25) + Description (20)

================
File: tests/test_awards.py
================
from app.models.resume import AwardItem
from app.modules.scoring.awards import calculate_awards_score

def test_calculate_awards_score():
    awards = [
        AwardItem(contest="International Coding Competition", prize="1st Place", description="Developed an AI model using Python.", role="Lead Developer", link="https://example.com", time="2023"),
        AwardItem(contest="Local Hackathon", prize="2nd Place", description="Built a web app using React.", role="Frontend Developer", link=None, time="2022")
    ]
    score = calculate_awards_score(awards)

    # Output the awards score
    print("=== Awards Score ===")
    print(f"Score: {score}")

# Run the test
test_calculate_awards_score()

================
File: tests/test_certification.py
================
from app.models.resume import CertificationItem
from app.modules.scoring.certifications import calculate_certifications_score

def test_calculate_certifications_score():
    certifications = [
        CertificationItem(name="AWS Certified Solutions Architect", org="Amazon Web Services", link="https://example.com"),
        CertificationItem(name="Google Data Engineer", org="Google", link=None)
    ]
    score = calculate_certifications_score(certifications)

    # Output the certifications score
    print("=== Certifications Score ===")
    print(f"Score: {score}")

# Run the test
test_calculate_certifications_score()

================
File: tests/test_cv_evaluation.py
================
from app.modules.document_extraction.extractor import extract_resume
from app.modules.summarization.evaluator import evaluate_resume

def test_cv_evaluation():
    # Path to the CV file (PDF or DOCX)
    cv_file = "D:\Downloads\LeMinhLocCV.pdf"  # Replace with the actual path to your CV file

    # Extract structured data from the CV
    resume = extract_resume(cv_file)

    # Evaluate the CV using an LLM
    evaluation = evaluate_resume(resume)

    # Print the evaluation
    print("=== CV Evaluation ===")
    print(evaluation)

# Run the test
test_cv_evaluation()

================
File: tests/test_cv_summarization.py
================
from app.modules.document_extraction.extractor import extract_resume
from app.modules.summarization.summarizer import summarize_resume

def test_cv_summarization():
    # Path to the CV file (PDF or DOCX)
    cv_file = "D:\Downloads\LeMinhLocCV.pdf"  # Replace with the actual path to your CV file

    # Extract structured data from the CV
    resume = extract_resume(cv_file)

    # Summarize the CV using an LLM
    summary = summarize_resume(resume)

    # Print the summary
    print("=== CV Summary ===")
    print(summary)

# Run the test
test_cv_summarization()

================
File: tests/test_document_extraction.py
================
from app.modules.document_extraction.extractor import extract_resume
from app.models.resume import Resume

def test_document_extraction():
    # Path to the CV file (PDF or DOCX)
    cv_file = "D:\Downloads\LeMinhLocCV.pdf"  # Replace with the actual path to your CV file

    # Extract structured data from the CV using LLM
    resume = extract_resume(cv_file)

    # Test that the returned value is a dictionary
    assert isinstance(resume, Resume)
    
    # Test that required fields exist and have expected types
    assert isinstance(resume.name, str)
    assert isinstance(resume.email, str)
    assert isinstance(resume.phone, str)
    assert isinstance(resume.education, list)
    assert isinstance(resume.professional_experience, list)
    assert isinstance(resume.skills, list)
    
    # Test that required fields are not empty or default values
    assert resume.name != ""
    assert resume.email != ""
    assert resume.phone != ""

    # Print the extracted resume data
    print("=== Extracted Resume ===")
    print(f"Name: {resume.name}")
    print(f"Location: {resume.location}")
    print(f"Email: {resume.email}")
    print(f"LinkedIn: {resume.linkedin}")
    print(f"Phone: {resume.phone}")
    print(f"Intro: {resume.intro}")
    print("\nEducation:")
    for edu in resume.education:
        print(f"- {edu.school}, {edu.major}, {edu.class_year}, GPA: {edu.gpa}")
    print("\nProfessional Experience:")
    for exp in resume.professional_experience:
        print(f"- {exp.company}, {exp.position}, {exp.duration}")
        print(f"  {exp.description}")
    print("\nProjects:")
    for project in resume.projects:
        print(f"- {project.name}, {project.tech}, {project.duration}")
        print(f"  {project.description}")
    print("\nAwards:")
    for award in resume.awards:
        print(f"- {award.contest}, {award.prize}, {award.time}")
        print(f"  {award.description}")
    print("\nCertifications:")
    for cert in resume.certifications:
        print(f"- {cert.name}, {cert.org}")
    print("\nSkills:")
    for skill in resume.skills:
        print(f"- {skill.name}: {', '.join(skill.list)}")

# Run the test
test_document_extraction()

================
File: tests/test_education.py
================
from app.models.resume import EducationItem
from app.modules.scoring.education import calculate_education_score

def test_calculate_education_score():
    education = [
        EducationItem(school="HUST", class_year="Senior", major="Computer Science", gpa=3.5)
    ]
    score = calculate_education_score(education)

    # Output the education score
    print("=== Education Score ===")
    print(f"Score: {score}")

# Run the test
test_calculate_education_score()

================
File: tests/test_embedding.py
================
from app.modules.embedding.embedder import get_embeddings

def test_get_embeddings():
    texts = ["Python developer", "Data scientist"]
    print("Processing")
    embeddings = get_embeddings(texts)

    # Output the embeddings
    print("=== Embeddings ===")
    for i, embedding in enumerate(embeddings):
        print(f"Text: {texts[i]}")
        print(f"Embedding: {embedding[:5]}...")  # Print first 5 values for brevity

# Run the test
test_get_embeddings()

================
File: tests/test_experience.py
================
from app.models.resume import ProfessionalExperienceItem
from app.modules.scoring.experience import calculate_experience_score

def test_calculate_experience_score():
    experience = [
        ProfessionalExperienceItem(company="FPT Software", location="Hanoi", position="Software Engineer", seniority="Junior", duration="2 years", description="Developed web applications using Python and Django.")
    ]
    score = calculate_experience_score(experience)

    # Output the experience score
    print("=== Experience Score ===")
    print(f"Score: {score}")

# Run the test
test_calculate_experience_score()

================
File: tests/test_scoring.py
================
from app.models.resume import Resume, EducationItem, ProfessionalExperienceItem, ProjectItem
from app.modules.scoring.scorer import calculate_total_score

def test_calculate_total_score():
    resume = Resume(
        name="John Doe",
        location="Hanoi",
        social=[],
        email="johndoe@example.com",
        phone="1234567890",
        intro="A passionate software engineer...",
        education=[
            EducationItem(school="HUST", class_year="Senior", major="Computer Science", gpa=3.5)
        ],
        professional_experience=[
            ProfessionalExperienceItem(
                company="FPT Software",
                location="Hanoi",
                position="Software Engineer",
                seniority="Junior",
                duration="Jan 2020 - Dec 2021",  # Valid duration format
                description="Developed web applications using Python and Django."
            )
        ],
        projects=[
            ProjectItem(
                name="E-commerce Website",
                tech="Python, Django, React",
                description="Developed a full-stack e-commerce website."
            )
        ],
        awards=[],
        certifications=[],
        skills=[]
    )
    score = calculate_total_score(resume)

    # Output the total score
    print("=== Total Resume Score ===")
    print(f"Score: {score}")

# Run the test
test_calculate_total_score()

================
File: utils/bias_check.py
================
def check_bias(text: str) -> bool:
    """
    Check for bias in the text (e.g., gender, ethnicity).
    """
    bias_keywords = ["male", "female", "asian", "black", "white"]
    return any(keyword in text.lower() for keyword in bias_keywords)

================
File: utils/json_lookup.py
================
import json
from pathlib import Path

def load_json_data(file_name: str) -> dict:
    """
    Load JSON data from the data folder.
    """
    file_path = Path(__file__).parent.parent / "data" / file_name
    with open(file_path, "r") as file:
        return json.load(file)

def get_university_score(university: str) -> int:
    """
    Get the score for a university based on its reputation.
    """
    universities = load_json_data("universities.json")
    return universities.get(university, 10)

def get_company_score(company: str) -> int:
    """
    Get the score for a company based on its size.
    """
    companies = load_json_data("companies.json")
    return companies.get(company, 10)

================
File: utils/normalization.py
================
import unicodedata

def normalize_text(text: str) -> str:
    """
    Normalize text by removing diacritics and converting to lowercase.
    """
    text = unicodedata.normalize("NFKD", text).encode("ascii", "ignore").decode("ascii")
    return text.lower()
